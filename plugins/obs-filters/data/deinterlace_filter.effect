uniform float4x4 ViewProj;
uniform texture2d image;
uniform float4x4 color_matrix;
uniform float3 color_range_min = {0.0, 0.0, 0.0};
uniform float3 color_range_max = {1.0, 1.0, 1.0};

uniform texture2d previous_image;
uniform int field_order;
uniform float2 pixel_size;
uniform float2 dimensions;

sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

// Defining yadif + bob makes for better thickness but blurs letters
// undefining is clearer for stationary stuff but deinterlaced look not so goodish
//#define YADIF_DISCARD
// Enable YADIF_SPATIAL_INTERLACE to see artifacts
//#define YADIF_SPATIAL_INTERLACE

//#define DX
#define OPENGL

#ifdef DX
#define ivec2 int2
#define ivec3 int3
#define LOAD(image, texel, x, y) image.Load(ivec3(select(texel, x, y), 0), 0)
#endif

#ifdef OPENGL
#define LOAD(image, texel, x, y) texelFetch(image, select(texel, x, y), 0)
#endif

ivec2 select(ivec2 texel, int x, int y)
{
	return texel + ivec2(x, y);
}

float4 load_at_prev(ivec2 texel, int x, int y)
{
	return LOAD(previous_image, texel, x, y);
}

float4 load_at_image(ivec2 texel, int x, int y)
{
	return LOAD(image, texel, x, y);
}

float4 load_at(ivec2 texel, int x, int y, int field)
{
	if(field == 0)
		return load_at_image(texel, x, y);
	else
		return load_at_prev(texel, x, y);
}

#define YADIF_UPDATE(c, level) 	\
	if(score.c < spatial_score.c) \
	{ \
		spatial_score.c = score.c; \
		spatial_pred.c = (load_at(texel, level, -1, field) + load_at(texel, -level, 1, field)).c / 2; \

#define YADIF_CHECK_ONE(level, c) \
{ \
	float4 score = abs(load_at(texel, -1 + level, 1, field) - load_at(texel, -1 - level, -1, field)) + \
	               abs(load_at(texel, level,      1, field) - load_at(texel, -level,     -1, field)) + \
	               abs(load_at(texel, 1 + level,  1, field) - load_at(texel, 1 - level,  -1, field)); \
	YADIF_UPDATE(c, level) } \
}

#define YADIF_CHECK(level) \
{ \
	float4 score = abs(load_at(texel, -1 + level, 1, field) - load_at(texel, -1 - level, -1, field)) + \
		           abs(load_at(texel, level,      1, field) - load_at(texel, -level,     -1, field)) + \
		           abs(load_at(texel, 1 + level,  1, field) - load_at(texel, 1 - level,  -1, field)); \
	YADIF_UPDATE(r, level) YADIF_CHECK_ONE(level * 2, r) } \
	YADIF_UPDATE(g, level) YADIF_CHECK_ONE(level * 2, g) } \
	YADIF_UPDATE(b, level) YADIF_CHECK_ONE(level * 2, b) } \
	YADIF_UPDATE(a, level) YADIF_CHECK_ONE(level * 2, a) } \
}

float4 texel_at_yadif(ivec2 texel, int field)
{

	if((texel.y % 2) == field)
		return load_at(texel, 0, 0, field);

	#define YADIF_AVG(x_off, y_off) ((load_at_prev(texel, x_off, y_off) + load_at_image(texel, x_off, y_off))/2)
	float4 c = load_at(texel, 0, 1, field),
	       d = YADIF_AVG(0, 0),
	       e = load_at(texel, 0, -1, field);

	float4 temporal_diff0 = (abs(load_at_prev(texel,  0, 0)      -     load_at_image(texel, 0, 0)))      / 2,
	       temporal_diff1 = (abs(load_at_prev(texel,  0, 1) - c) + abs(load_at_prev(texel,  0, -1) - e)) / 2,
	       temporal_diff2 = (abs(load_at_image(texel, 0, 1) - c) + abs(load_at_image(texel, 0, -1) - e)) / 2,
	       diff = max(temporal_diff0, max(temporal_diff1, temporal_diff2));

	float4 spatial_pred = (c + e) / 2,
	       spatial_score = abs(load_at(texel, -1, 1, field) - load_at(texel, -1, -1, field)) +
		       	           abs(c - e) +
			               abs(load_at(texel, 1,  1, field) - load_at(texel, 1,  -1, field)) - 1;

	YADIF_CHECK(-1)
	YADIF_CHECK(1)

	#ifdef YADIF_SPATIAL_INTERLACE
	float4 b = YADIF_AVG(0, 2),
	       f = YADIF_AVG(0, -2);

	float4 max_ = max(d - e, max(d - c, min(b - c, f - e))),
	       min_ = min(d - e, min(d - c, max(b - c, f - e)));

	diff = max(diff, max(min_, -max_));
	#else
	diff = max(diff, max(min(d - e, d - c), -max(d - e, d - c)));
	#endif

#define YADIF_SPATIAL(c) \
{ \
	if(spatial_pred.c > d.c + diff.c) \
		spatial_pred.c = d.c + diff.c; \
	else if(spatial_pred.c < d.c - diff.c) \
		spatial_pred.c = d.c - diff.c; \
}

	YADIF_SPATIAL(r)
	YADIF_SPATIAL(g)
	YADIF_SPATIAL(b)
	YADIF_SPATIAL(a)

	return spatial_pred;
}

#ifdef OPENGL
float4 texel_at_diff(ivec2 texel, int field)
{
	float4 current = load_at_image(texel, 0, 0);
	float4 prev = load_at_prev(texel, 0, 0);

	if (current != prev)
		current.r = 1;
	
	return current;
}
#endif

float4 texel_at_discard(ivec2 texel, int field)
{
		return load_at_image(texel, 0, (texel.y + field) % 2);
}

float4 texel_at_blend_around(ivec2 texel, int field)
{
	return (load_at_image(texel, 0, 0) * 2 + 
            load_at_image(texel, 0, -1) +
            load_at_image(texel, 0, 1)) / 4;
}

float4 texel_at_linear(ivec2 texel, int field)
{
	if ((texel.y % 2) == field)
		return load_at_image(texel, 0, 0);
	return (load_at_image(texel, 0, -1) + load_at_image(texel, 0, 1)) / 2;
}

float4 texel_at_discard_yadif(ivec2 texel, int field)
{
	return (texel_at_yadif(texel, field) + texel_at_discard(texel, field)) / 2;
}

float4 sample_pixel(float2 coord)
{	
	#ifndef YADIF_DISCARD
	return texel_at_yadif(
	#else
	return texel_at_discard_yadif(
	#endif
		ivec2(coord * dimensions), field_order);
}

float4 PSDeinterlaceRGBA(VertData v_in) : TARGET
{
	// hack
	previous_image.Sample(textureSampler, float2(0, 0));
	image.Sample(textureSampler, float2(0, 0));
	return sample_pixel(v_in.uv);
}

float4 PSDeinterlaceMatrix(VertData v_in) : TARGET
{
	float4 yuv = image.Sample(textureSampler, v_in.uv);
	
	yuv.xyz = clamp(yuv.xyz, color_range_min, color_range_max);

	return saturate(mul(float4(yuv.xyz, 1.0), color_matrix));
}

VertData VSDefault(VertData v_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSDeinterlaceRGBA(v_in);
	}
}

technique DrawMatrix
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSDeinterlaceMatrix(v_in);
	}
}
