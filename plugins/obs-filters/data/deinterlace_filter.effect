uniform float4x4 ViewProj;
uniform texture2d image;
uniform float4x4 color_matrix;
uniform float3 color_range_min = {0.0, 0.0, 0.0};
uniform float3 color_range_max = {1.0, 1.0, 1.0};

uniform texture2d previous_image;
uniform int field_order;
uniform float2 pixel_size;
uniform float2 dimensions;

sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

float2 select(float2 texel, int x, int y)
{
	return float2(texel + (float2(x, y) / dimensions));
}

float4 load_at_prev(float2 texel, int x, int y)
{
	return previous_image.Sample(textureSampler, select(texel, x, y));
}

float4 load_at_image(float2 texel, int x, int y)
{
	return image.Sample(textureSampler, select(texel, x, y));
}

float4 load_at(float2 texel, int x, int y, int field)
{
	if(field == 0)
		return load_at_image(texel, x, y);
	else
		return load_at_prev(texel, x, y);
}

#define YADIF_UPDATE(c, level) 	\
	if(score.c < spatial_score.c) \
	{ \
		spatial_score.c = score.c; \
		spatial_pred.c = (load_at(texel, level, -1, field) + load_at(texel, -level, 1, field)).c / 2; \

#define YADIF_CHECK_ONE(level, c) \
{ \
	float4 score = abs(load_at(texel, -1 + level, 1, field) - load_at(texel, -1 - level, -1, field)) + \
	               abs(load_at(texel, level,      1, field) - load_at(texel, -level,     -1, field)) + \
	               abs(load_at(texel, 1 + level,  1, field) - load_at(texel, 1 - level,  -1, field)); \
	YADIF_UPDATE(c, level) } \
}

#define YADIF_CHECK(level) \
{ \
	float4 score = abs(load_at(texel, -1 + level, 1, field) - load_at(texel, -1 - level, -1, field)) + \
		           abs(load_at(texel, level,      1, field) - load_at(texel, -level,     -1, field)) + \
		           abs(load_at(texel, 1 + level,  1, field) - load_at(texel, 1 - level,  -1, field)); \
	YADIF_UPDATE(r, level) YADIF_CHECK_ONE(level * 2, r) } \
	YADIF_UPDATE(g, level) YADIF_CHECK_ONE(level * 2, g) } \
	YADIF_UPDATE(b, level) YADIF_CHECK_ONE(level * 2, b) } \
	YADIF_UPDATE(a, level) YADIF_CHECK_ONE(level * 2, a) } \
}

float4 texel_at_yadif(float2 texel, int field)
{

	if((int(texel.y * dimensions.y) % 2) == field)
		return load_at(texel, 0, 0, field);

	#define YADIF_AVG(x_off, y_off) ((load_at_prev(texel, x_off, y_off) + load_at_image(texel, x_off, y_off))/2)
	float4 b = YADIF_AVG(0, 2),
	       c = load_at(texel, 0, 1, field),
	       d = YADIF_AVG(0, 0),
	       e = load_at(texel, 0, -1, field),
	       f = YADIF_AVG(0, -2);

	float4 temporal_diff0 = (abs(load_at_prev(texel,  0, 0)      -     load_at_image(texel, 0, 0)))      / 2,
	       temporal_diff1 = (abs(load_at_prev(texel,  0, 1) - c) + abs(load_at_prev(texel,  0, -1) - e)) / 2,
	       temporal_diff2 = (abs(load_at_image(texel, 0, 1) - c) + abs(load_at_image(texel, 0, -1) - e)) / 2,
	       diff = max(temporal_diff0, max(temporal_diff1, temporal_diff2));

	float4 spatial_pred = (c + e) / 2,
	       spatial_score = abs(load_at(texel, -1, 1, field) - load_at(texel, -1, -1, field)) +
		       	           abs(c - e) +
			               abs(load_at(texel, 1,  1, field) - load_at(texel, 1,  -1, field)) - 1;

	YADIF_CHECK(-1)
	YADIF_CHECK(1)

	float4 max_ = max(d - e, max(d - c, min(b - c, f - e))),
	       min_ = min(d - e, min(d - c, max(b - c, f - e)));

	diff = max(diff, max(min_, -max_));

 #define YADIF_SPATIAL(c) \
 { \
 	if(spatial_pred.c > d.c + diff.c) \
 		spatial_pred.c = d.c + diff.c; \
 	else if(spatial_pred.c < d.c - diff.c) \
 		spatial_pred.c = d.c - diff.c; \
 }

	YADIF_SPATIAL(r)
	YADIF_SPATIAL(g)
	YADIF_SPATIAL(b)
	YADIF_SPATIAL(a)

	return spatial_pred;
}

float4 texel_at_diff(float2 texel, int field)
{
	float4 current = load_at_image(texel, 0, 0);
	float4 prev = load_at_prev(texel, 0, 0);

	if (current != prev)
		current.r = 1;
	
	return current;
}

float4 texel_at_linear(float2 texel, int field)
{
	if ((int(texel.y * dimensions.y) % 2) == field)
		return load_at_image(texel, 0, 0);
	return (load_at_image(texel, 0, -1) + load_at_image(texel, 0, 1)) / 2;
}

float4 texel_at_blend_up(float2 texel, int field)
{
	return (load_at_image(texel, 0, 0) + load_at_image(texel, 0, 1)) / 2;
}

float4 texel_at_blend_around(float2 texel, int field)
{
	return (load_at_image(texel, 0, 0) * 2 + 
            load_at_image(texel, 0, -1) +
            load_at_image(texel, 0, 1)) / 4;
}

float4 sample_pixel(float2 coord)
{	
	return texel_at_yadif(coord, field_order);
}

float4 PSDeinterlaceRGBA(VertData v_in) : TARGET
{
	return sample_pixel(v_in.uv);
}

float4 PSDeinterlaceMatrix(VertData v_in) : TARGET
{
	float4 yuv = image.Sample(textureSampler, v_in.uv);
	
	yuv.xyz = clamp(yuv.xyz, color_range_min, color_range_max);

	return saturate(mul(float4(yuv.xyz, 1.0), color_matrix));
}

VertData VSDefault(VertData v_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSDeinterlaceRGBA(v_in);
	}
}

technique DrawMatrix
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSDeinterlaceMatrix(v_in);
	}
}
